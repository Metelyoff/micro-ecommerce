---
apiVersion: v1
kind: ConfigMap
metadata:
  name: order-postgres-init-sql
data:
  order_init.sql: |
    \c postgres;
    DROP DATABASE IF EXISTS order_service_db;
    CREATE DATABASE order_service_db;
    \c order_service_db;
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: order-postgres-config
data:
  postgresql.conf: |
    listen_addresses = '*'
    max_connections = 100
    shared_buffers = 128MB
    dynamic_shared_memory_type = posix
    max_wal_size = 1GB
    min_wal_size = 80MB
    log_timezone = 'Etc/UTC'
    timezone = 'Etc/UTC'
    lc_messages = 'en_US.utf8'
    lc_monetary = 'en_US.utf8'
    lc_numeric = 'en_US.utf8'
    lc_time = 'en_US.utf8'
    default_text_search_config = 'pg_catalog.english'
    wal_level = logical
    max_replication_slots = 10
    max_wal_senders = 10
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: order-service-db-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: order-postgres
spec:
  serviceName: "order-postgres"
  replicas: 1
  selector:
    matchLabels:
      app: order-postgres
  template:
    metadata:
      labels:
        app: order-postgres
    spec:
      containers:
        - name: postgres
          image: postgres:15
          ports:
            - containerPort: 5432
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
            - name: config
              mountPath: /etc/postgresql/postgresql.conf
              subPath: postgresql.conf
            - name: init-sql
              mountPath: /docker-entrypoint-initdb.d/order_init.sql
              subPath: order_init.sql
          env:
            - name: POSTGRES_USER
              value: postgres
            - name: POSTGRES_PASSWORD
              value: postgres
            - name: POSTGRES_DB
              value: order_service_db
          args:
            - "-c"
            - "config_file=/etc/postgresql/postgresql.conf"
          readinessProbe:
            exec:
              command: ["pg_isready", "-U", "postgres"]
            initialDelaySeconds: 5
            periodSeconds: 10
      volumes:
        - name: config
          configMap:
            name: order-postgres-config
        - name: init-sql
          configMap:
            name: order-postgres-init-sql
  volumeClaimTemplates:
    - metadata:
        name: postgres-data
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 1Gi
---
apiVersion: v1
kind: Service
metadata:
  name: order-service-db
spec:
  selector:
    app: order-postgres
  ports:
    - protocol: TCP
      port: 5432
      targetPort: 5432
  type: ClusterIP
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: payment-postgres-init-sql
data:
  payment_init.sql: |
    \c postgres;
    DROP DATABASE IF EXISTS payment_service_db;
    CREATE DATABASE payment_service_db;
    \c payment_service_db;
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: payment-postgres-config
data:
  postgresql.conf: |
    listen_addresses = '*'
    max_connections = 100
    shared_buffers = 128MB
    dynamic_shared_memory_type = posix
    max_wal_size = 1GB
    min_wal_size = 80MB
    log_timezone = 'Etc/UTC'
    timezone = 'Etc/UTC'
    lc_messages = 'en_US.utf8'
    lc_monetary = 'en_US.utf8'
    lc_numeric = 'en_US.utf8'
    lc_time = 'en_US.utf8'
    default_text_search_config = 'pg_catalog.english'
    wal_level = logical
    max_replication_slots = 10
    max_wal_senders = 10
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: payment-service-db-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: payment-postgres
spec:
  serviceName: "payment-postgres"
  replicas: 1
  selector:
    matchLabels:
      app: payment-postgres
  template:
    metadata:
      labels:
        app: payment-postgres
    spec:
      containers:
        - name: postgres
          image: postgres:15
          ports:
            - containerPort: 5432
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
            - name: config
              mountPath: /etc/postgresql/postgresql.conf
              subPath: postgresql.conf
            - name: init-sql
              mountPath: /docker-entrypoint-initdb.d/payment_init.sql
              subPath: payment_init.sql
          env:
            - name: POSTGRES_USER
              value: postgres
            - name: POSTGRES_PASSWORD
              value: postgres
            - name: POSTGRES_DB
              value: payment_service_db
          args:
            - "-c"
            - "config_file=/etc/postgresql/postgresql.conf"
          readinessProbe:
            exec:
              command: ["pg_isready", "-U", "postgres"]
            initialDelaySeconds: 5
            periodSeconds: 10
      volumes:
        - name: config
          configMap:
            name: payment-postgres-config
        - name: init-sql
          configMap:
            name: payment-postgres-init-sql
  volumeClaimTemplates:
    - metadata:
        name: postgres-data
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 1Gi
---
apiVersion: v1
kind: Service
metadata:
  name: payment-service-db
spec:
  selector:
    app: payment-postgres
  ports:
    - protocol: TCP
      port: 5432
      targetPort: 5432
  type: ClusterIP
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: inventory-postgres-init-sql
data:
  inventory_init.sql: |
    \c postgres;
    DROP DATABASE IF EXISTS inventory_service_db;
    CREATE DATABASE inventory_service_db;
    \c inventory_service_db;
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: inventory-postgres-config
data:
  postgresql.conf: |
    listen_addresses = '*'
    max_connections = 100
    shared_buffers = 128MB
    dynamic_shared_memory_type = posix
    max_wal_size = 1GB
    min_wal_size = 80MB
    log_timezone = 'Etc/UTC'
    timezone = 'Etc/UTC'
    lc_messages = 'en_US.utf8'
    lc_monetary = 'en_US.utf8'
    lc_numeric = 'en_US.utf8'
    lc_time = 'en_US.utf8'
    default_text_search_config = 'pg_catalog.english'
    wal_level = logical
    max_replication_slots = 10
    max_wal_senders = 10
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: inventory-service-db-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: inventory-postgres
spec:
  serviceName: "inventory-postgres"
  replicas: 1
  selector:
    matchLabels:
      app: inventory-postgres
  template:
    metadata:
      labels:
        app: inventory-postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15
        ports:
        - containerPort: 5432
        volumeMounts:
        - name: postgres-data
          mountPath: /var/lib/postgresql/data
        - name: config
          mountPath: /etc/postgresql/postgresql.conf
          subPath: postgresql.conf
        - name: init-sql
          mountPath: /docker-entrypoint-initdb.d/inventory_init.sql
          subPath: inventory_init.sql
        env:
        - name: POSTGRES_USER
          value: postgres
        - name: POSTGRES_PASSWORD
          value: postgres
        - name: POSTGRES_DB
          value: inventory_service_db
        args:
          - "-c"
          - "config_file=/etc/postgresql/postgresql.conf"
        readinessProbe:
          exec:
            command: ["pg_isready", "-U", "postgres"]
          initialDelaySeconds: 5
          periodSeconds: 10
      volumes:
      - name: config
        configMap:
          name: inventory-postgres-config
      - name: init-sql
        configMap:
          name: inventory-postgres-init-sql
  volumeClaimTemplates:
  - metadata:
      name: postgres-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi
---
apiVersion: v1
kind: Service
metadata:
  name: inventory-service-db
spec:
  selector:
    app: inventory-postgres
  ports:
    - protocol: TCP
      port: 5432
      targetPort: 5432
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kafka
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kafka
  template:
    metadata:
      labels:
        app: kafka
    spec:
      containers:
        - name: kafka
          image: apache/kafka:latest
          ports:
            - containerPort: 29092
            - containerPort: 29093
          env:
            - name: KAFKA_BROKER_ID
              value: "1"
            - name: KAFKA_LISTENER_SECURITY_PROTOCOL_MAP
              value: "INTERNAL:PLAINTEXT,CONTROLLER:PLAINTEXT"
            - name: KAFKA_ADVERTISED_LISTENERS
              value: "INTERNAL://kafka:29092"
            - name: KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR
              value: "1"
            - name: KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS
              value: "0"
            - name: KAFKA_TRANSACTION_STATE_LOG_MIN_ISR
              value: "1"
            - name: KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR
              value: "1"
            - name: KAFKA_PROCESS_ROLES
              value: "broker,controller"
            - name: KAFKA_NODE_ID
              value: "1"
            - name: KAFKA_CONTROLLER_QUORUM_VOTERS
              value: "1@kafka:29093"
            - name: KAFKA_LISTENERS
              value: "INTERNAL://:29092,CONTROLLER://:29093"
            - name: KAFKA_INTER_BROKER_LISTENER_NAME
              value: "INTERNAL"
            - name: KAFKA_CONTROLLER_LISTENER_NAMES
              value: "CONTROLLER"
            - name: KAFKA_HEAP_OPTS
              value: "-Xms512m -Xmx512m"
            - name: CLUSTER_ID
              value: "ecommerce"
#          resources:
#            limits:
#              memory: "512Mi"
#              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: kafka
spec:
  selector:
    app: kafka
  ports:
    - name: internal
      protocol: TCP
      port: 29092
      targetPort: 29092
    - name: controller
      protocol: TCP
      port: 29093
      targetPort: 29093
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kafka-ui
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kafka-ui
  template:
    metadata:
      labels:
        app: kafka-ui
    spec:
      containers:
        - name: kafka-ui
          image: provectuslabs/kafka-ui:latest
          ports:
            - containerPort: 8080
          env:
            - name: KAFKA_CLUSTERS_0_NAME
              value: "ecommerce"
            - name: KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS
              value: "kafka:29092"
            - name: DYNAMIC_CONFIG_ENABLED
              value: "true"
            - name: SPRING_PROFILES_ACTIVE
              value: "prod"
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: kafka-ui
spec:
  selector:
    app: kafka-ui
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
      name: http
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kafka-ui-ingress
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: web
spec:
  ingressClassName: traefik
  rules:
    - host: kafka.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: kafka-ui
                port:
                  number: 8080
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kafka-ui
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kafka-ui
  template:
    metadata:
      labels:
        app: kafka-ui
    spec:
      containers:
        - name: kafka-ui
          image: provectuslabs/kafka-ui:latest
          ports:
            - containerPort: 8080
          env:
            - name: KAFKA_CLUSTERS_0_NAME
              value: "ecommerce"
            - name: KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS
              value: "kafka:29092"
            - name: DYNAMIC_CONFIG_ENABLED
              value: "true"
            - name: SPRING_PROFILES_ACTIVE
              value: "prod"
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: kafka-ui
spec:
  selector:
    app: kafka-ui
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
      name: http
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: debezium
spec:
  replicas: 1
  selector:
    matchLabels:
      app: debezium
  template:
    metadata:
      labels:
        app: debezium
    spec:
      containers:
        - name: debezium
          image: debezium/connect:2.7.3.Final
          ports:
            - containerPort: 8083
          env:
            - name: BOOTSTRAP_SERVERS
              value: kafka:29092
            - name: GROUP_ID
              value: "1"
            - name: CONFIG_STORAGE_TOPIC
              value: debezium_config
            - name: OFFSET_STORAGE_TOPIC
              value: debezium_offsets
            - name: STATUS_STORAGE_TOPIC
              value: debezium_status
            - name: KEY_CONVERTER_SCHEMAS_ENABLE
              value: "false"
            - name: VALUE_CONVERTER_SCHEMAS_ENABLE
              value: "false"
            - name: CONNECT_KEY_CONVERTER
              value: org.apache.kafka.connect.json.JsonConverter
            - name: CONNECT_VALUE_CONVERTER
              value: org.apache.kafka.connect.json.JsonConverter
#          resources:
#            limits:
#              memory: "512Mi"
#              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: debezium
spec:
  selector:
    app: debezium
  ports:
    - protocol: TCP
      port: 8083
      targetPort: 8083
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: debezium-ui
spec:
  replicas: 1
  selector:
    matchLabels:
      app: debezium-ui
  template:
    metadata:
      labels:
        app: debezium-ui
    spec:
      containers:
        - name: debezium-ui
          image: docker.io/metelyoff/debezium-ui-arm64:latest
          ports:
            - containerPort: 8080
          env:
            - name: KAFKA_CONNECT_URIS
              value: "http://debezium:8083"
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: debezium-ui
spec:
  selector:
    app: debezium-ui
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
      name: http
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: debezium-ui-ingress
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: web
spec:
  ingressClassName: traefik
  rules:
    - host: debezium.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: debezium-ui
                port:
                  number: 8080
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: debezium-connectors
data:
  register-connectors.sh: |
    #!/bin/sh
    echo 'Waiting for Debezium REST API...'
    until curl -s http://debezium:8083/connectors > /dev/null; do
      echo '...still waiting...'
      sleep 2
    done
    
    echo 'Debezium is ready. Registering connectors...'
    for f in /connectors/*.json; do
      name=$(grep -o '"name"[[:space:]]*:[[:space:]]*"[^"]*"' "$f" | head -n1 | cut -d':' -f2 | tr -d ' "')
      echo "Registering connector: $name"
      response=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
        -H "Content-Type: application/json" \
        --data @"$f" http://debezium:8083/connectors)
    
      if [ "$response" -eq 200 ]; then
        echo "Registered $name"
      elif [ "$response" -eq 409 ]; then
        echo "Connector $name already exists"
      else
        echo "Failed to register $name (HTTP $response)"
      fi
    done
  inventory-service-connector.json: |
    {
      "name": "inventory-service-connector",
      "config": {
        "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
        "tasks.max": "1",
        "database.hostname": "inventory-service-db",
        "database.port": "5432",
        "database.user": "postgres",
        "database.password": "postgres",
        "database.dbname": "inventory_service_db",
        "database.server.name": "inventory_service",
        "plugin.name": "pgoutput",
        "slot.name": "debezium_slot",
        "topic.prefix": "inventory-service",
        "key.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter.schemas.enable": "false",
        "decimal.handling.mode": "string",
        "include.transaction": true,
        "after.state.only": "true",
        "transforms": "unwrap",
        "transforms.unwrap.type": "io.debezium.transforms.ExtractNewRecordState",
        "transforms.unwrap.drop.tombstones": "true",
        "table.include.list": "public.outbox_events"
      }
    }
  order-service-connector.json: |
    {
      "name": "order-service-connector",
      "config": {
        "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
        "tasks.max": "1",
        "database.hostname": "order-service-db",
        "database.port": "5432",
        "database.user": "postgres",
        "database.password": "postgres",
        "database.dbname": "order_service_db",
        "database.server.name": "order_service",
        "plugin.name": "pgoutput",
        "slot.name": "debezium_slot",
        "topic.prefix": "order-service",
        "key.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter.schemas.enable": "false",
        "decimal.handling.mode": "string",
        "include.transaction": true,
        "after.state.only": "true",
        "transforms": "unwrap",
        "transforms.unwrap.type": "io.debezium.transforms.ExtractNewRecordState",
        "transforms.unwrap.drop.tombstones": "true",
        "table.include.list": "public.outbox_events"
      }
    }
  payment-service-connector.json: |
    {
      "name": "payment-service-connector",
      "config": {
        "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
        "tasks.max": "1",
        "database.hostname": "payment-service-db",
        "database.port": "5432",
        "database.user": "postgres",
        "database.password": "postgres",
        "database.dbname": "payment_service_db",
        "database.server.name": "payment_service",
        "plugin.name": "pgoutput",
        "slot.name": "debezium_slot",
        "topic.prefix": "payment-service",
        "key.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter.schemas.enable": "false",
        "decimal.handling.mode": "string",
        "include.transaction": true,
        "after.state.only": "true",
        "transforms": "unwrap",
        "transforms.unwrap.type": "io.debezium.transforms.ExtractNewRecordState",
        "transforms.unwrap.drop.tombstones": "true",
        "table.include.list": "public.outbox_events"
      }
    }
---
apiVersion: batch/v1
kind: Job
metadata:
  name: debezium-connector
spec:
  template:
    spec:
      restartPolicy: Never
      containers:
        - name: debezium-connector
          image: curlimages/curl
          command: [ "sh", "/connectors/register-connectors.sh" ]
          volumeMounts:
            - name: connector-configs
              mountPath: /connectors
      volumes:
        - name: connector-configs
          configMap:
            name: debezium-connectors
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: payment-service
  labels:
    app: payment-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: payment-service
  template:
    metadata:
      labels:
        app: payment-service
    spec:
      containers:
        - name: payment-service
          image: metelyoff/payment-service:latest
          ports:
            - containerPort: 8080
          env:
            - name: DATABASE_URL
              value: jdbc:postgresql://payment-service-db:5432/payment_service_db
            - name: DATABASE_USERNAME
              value: postgres
            - name: DATABASE_PASSWORD
              value: postgres
            - name: KAFKA_URI
              value: kafka:29092
            - name: DEBEZIUM_DESTINATION
              value: payment-service.public.outbox_events
            - name: OUTBOX_TOPICS
              value: order-service.public.outbox_events,inventory-service.public.outbox_events
            - name: EXPIRE_DELAY_MILLIS
              value: "60000"
          readinessProbe:
            httpGet:
              path: /actuator/health
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
            failureThreshold: 10
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: payment-service
spec:
  selector:
    app: payment-service
  ports:
    - protocol: TCP
      port: 8085
      targetPort: 8080
      name: http
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: inventory-service
  labels:
    app: inventory-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: inventory-service
  template:
    metadata:
      labels:
        app: inventory-service
    spec:
      containers:
        - name: inventory-service
          image: metelyoff/inventory-service:latest
          ports:
            - containerPort: 8080
          env:
            - name: DATABASE_URL
              value: jdbc:postgresql://inventory-service-db:5432/inventory_service_db
            - name: DATABASE_USERNAME
              value: postgres
            - name: DATABASE_PASSWORD
              value: postgres
            - name: KAFKA_URI
              value: kafka:29092
            - name: DEBEZIUM_DESTINATION
              value: inventory-service.public.outbox_events
            - name: OUTBOX_TOPICS
              value: order-service.public.outbox_events,payment-service.public.outbox_events
          readinessProbe:
            httpGet:
              path: /actuator/health
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
            failureThreshold: 10
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: inventory-service
spec:
  selector:
    app: inventory-service
  ports:
    - protocol: TCP
      port: 8084
      targetPort: 8080
      name: http
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service
  labels:
    app: order-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: order-service
  template:
    metadata:
      labels:
        app: order-service
    spec:
      containers:
        - name: order-service
          image: metelyoff/order-service:latest
          ports:
            - containerPort: 8080
          env:
            - name: DATABASE_URL
              value: jdbc:postgresql://order-service-db:5432/order_service_db
            - name: DATABASE_USERNAME
              value: postgres
            - name: DATABASE_PASSWORD
              value: postgres
            - name: KAFKA_URI
              value: kafka:29092
            - name: DEBEZIUM_DESTINATION
              value: order-service.public.outbox_events
            - name: OUTBOX_TOPICS
              value: payment-service.public.outbox_events,inventory-service.public.outbox_events
          readinessProbe:
            httpGet:
              path: /actuator/health
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
            failureThreshold: 10
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: order-service
spec:
  selector:
    app: order-service
  ports:
    - protocol: TCP
      port: 8086
      targetPort: 8080
      name: http
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
  labels:
    app: web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
        - name: web
          image: metelyoff/webapp:latest
          ports:
            - containerPort: 80
          env:
            - name: REACT_APP_PRODUCTS_API_URL
              value: https://rpik3s.xyz/api
            - name: REACT_APP_ORDERS_API_URL
              value: https://rpik3s.xyz/api
            - name: REACT_APP_PAYMENTS_API_URL
              value: https://rpik3s.xyz/api
            - name: BACKEND_PRODUCTS_API_URL
              value: http://inventory-service:8084
            - name: BACKEND_ORDERS_API_URL
              value: http://order-service:8086
            - name: BACKEND_PAYMENTS_API_URL
              value: http://payment-service:8085
          readinessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 30
            timeoutSeconds: 10
            failureThreshold: 3
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: web
spec:
  selector:
    app: web
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
      name: http
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web-ingress
  namespace: default
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
    - host: rpik3s.xyz
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web
                port:
                  number: 80
