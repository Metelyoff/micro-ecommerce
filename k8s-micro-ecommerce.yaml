apiVersion: v1
kind: Namespace
metadata:
  name: ecommerce
---
apiVersion: v1
kind: Namespace
metadata:
  name: monitoring
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: order-postgres-init-sql
  namespace: ecommerce
data:
  order_init.sql: |
    \c postgres;
    DROP DATABASE IF EXISTS order_service_db;
    CREATE DATABASE order_service_db;
    \c order_service_db;
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: order-postgres-config
  namespace: ecommerce
data:
  postgresql.conf: |
    listen_addresses = '*'
    max_connections = 100
    shared_buffers = 128MB
    dynamic_shared_memory_type = posix
    max_wal_size = 1GB
    min_wal_size = 80MB
    log_timezone = 'Etc/UTC'
    timezone = 'Etc/UTC'
    lc_messages = 'en_US.utf8'
    lc_monetary = 'en_US.utf8'
    lc_numeric = 'en_US.utf8'
    lc_time = 'en_US.utf8'
    default_text_search_config = 'pg_catalog.english'
    wal_level = logical
    max_replication_slots = 10
    max_wal_senders = 10
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: order-postgres
  namespace: ecommerce
spec:
  serviceName: "order-postgres"
  replicas: 1
  selector:
    matchLabels:
      app: order-postgres
  template:
    metadata:
      labels:
        app: order-postgres
    spec:
      containers:
        - name: postgres
          image: postgres:15
          ports:
            - containerPort: 5432
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
            - name: config
              mountPath: /etc/postgresql/postgresql.conf
              subPath: postgresql.conf
            - name: init-sql
              mountPath: /docker-entrypoint-initdb.d/order_init.sql
              subPath: order_init.sql
          env:
            - name: POSTGRES_USER
              value: "${ORDER_POSTGRES_USER}"
            - name: POSTGRES_PASSWORD
              value: "${ORDER_POSTGRES_PASSWORD}"
            - name: POSTGRES_DB
              value: order_service_db
          args:
            - "-c"
            - "config_file=/etc/postgresql/postgresql.conf"
          readinessProbe:
            exec:
              command: ["pg_isready", "-U", "postgres"]
            initialDelaySeconds: 5
            periodSeconds: 10
      volumes:
        - name: config
          configMap:
            name: order-postgres-config
        - name: init-sql
          configMap:
            name: order-postgres-init-sql
  volumeClaimTemplates:
    - metadata:
        name: postgres-data
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 1Gi
---
apiVersion: v1
kind: Service
metadata:
  name: order-service-db
  namespace: ecommerce
spec:
  selector:
    app: order-postgres
  ports:
    - protocol: TCP
      port: 5432
      targetPort: 5432
  type: ClusterIP
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: payment-postgres-init-sql
  namespace: ecommerce
data:
  payment_init.sql: |
    \c postgres;
    DROP DATABASE IF EXISTS payment_service_db;
    CREATE DATABASE payment_service_db;
    \c payment_service_db;
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: payment-postgres-config
  namespace: ecommerce
data:
  postgresql.conf: |
    listen_addresses = '*'
    max_connections = 100
    shared_buffers = 128MB
    dynamic_shared_memory_type = posix
    max_wal_size = 1GB
    min_wal_size = 80MB
    log_timezone = 'Etc/UTC'
    timezone = 'Etc/UTC'
    lc_messages = 'en_US.utf8'
    lc_monetary = 'en_US.utf8'
    lc_numeric = 'en_US.utf8'
    lc_time = 'en_US.utf8'
    default_text_search_config = 'pg_catalog.english'
    wal_level = logical
    max_replication_slots = 10
    max_wal_senders = 10
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: payment-postgres
  namespace: ecommerce
spec:
  serviceName: "payment-postgres"
  replicas: 1
  selector:
    matchLabels:
      app: payment-postgres
  template:
    metadata:
      labels:
        app: payment-postgres
    spec:
      containers:
        - name: postgres
          image: postgres:15
          ports:
            - containerPort: 5432
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
            - name: config
              mountPath: /etc/postgresql/postgresql.conf
              subPath: postgresql.conf
            - name: init-sql
              mountPath: /docker-entrypoint-initdb.d/payment_init.sql
              subPath: payment_init.sql
          env:
            - name: POSTGRES_USER
              value: "${PAYMENT_POSTGRES_USER}"
            - name: POSTGRES_PASSWORD
              value: "${PAYMENT_POSTGRES_PASSWORD}"
            - name: POSTGRES_DB
              value: payment_service_db
          args:
            - "-c"
            - "config_file=/etc/postgresql/postgresql.conf"
          readinessProbe:
            exec:
              command: ["pg_isready", "-U", "postgres"]
            initialDelaySeconds: 5
            periodSeconds: 10
      volumes:
        - name: config
          configMap:
            name: payment-postgres-config
        - name: init-sql
          configMap:
            name: payment-postgres-init-sql
  volumeClaimTemplates:
    - metadata:
        name: postgres-data
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 1Gi
---
apiVersion: v1
kind: Service
metadata:
  name: payment-service-db
  namespace: ecommerce
spec:
  selector:
    app: payment-postgres
  ports:
    - protocol: TCP
      port: 5432
      targetPort: 5432
  type: ClusterIP
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: inventory-postgres-init-sql
  namespace: ecommerce
data:
  inventory_init.sql: |
    \c postgres;
    DROP DATABASE IF EXISTS inventory_service_db;
    CREATE DATABASE inventory_service_db;
    \c inventory_service_db;
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: inventory-postgres-config
  namespace: ecommerce
data:
  postgresql.conf: |
    listen_addresses = '*'
    max_connections = 100
    shared_buffers = 128MB
    dynamic_shared_memory_type = posix
    max_wal_size = 1GB
    min_wal_size = 80MB
    log_timezone = 'Etc/UTC'
    timezone = 'Etc/UTC'
    lc_messages = 'en_US.utf8'
    lc_monetary = 'en_US.utf8'
    lc_numeric = 'en_US.utf8'
    lc_time = 'en_US.utf8'
    default_text_search_config = 'pg_catalog.english'
    wal_level = logical
    max_replication_slots = 10
    max_wal_senders = 10
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: inventory-postgres
  namespace: ecommerce
spec:
  serviceName: "inventory-postgres"
  replicas: 1
  selector:
    matchLabels:
      app: inventory-postgres
  template:
    metadata:
      labels:
        app: inventory-postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15
        ports:
        - containerPort: 5432
        volumeMounts:
        - name: postgres-data
          mountPath: /var/lib/postgresql/data
        - name: config
          mountPath: /etc/postgresql/postgresql.conf
          subPath: postgresql.conf
        - name: init-sql
          mountPath: /docker-entrypoint-initdb.d/inventory_init.sql
          subPath: inventory_init.sql
        env:
        - name: POSTGRES_USER
          value: "${INVENTORY_POSTGRES_USER}"
        - name: POSTGRES_PASSWORD
          value: "${INVENTORY_POSTGRES_PASSWORD}"
        - name: POSTGRES_DB
          value: inventory_service_db
        args:
          - "-c"
          - "config_file=/etc/postgresql/postgresql.conf"
        readinessProbe:
          exec:
            command: ["pg_isready", "-U", "postgres"]
          initialDelaySeconds: 5
          periodSeconds: 10
      volumes:
      - name: config
        configMap:
          name: inventory-postgres-config
      - name: init-sql
        configMap:
          name: inventory-postgres-init-sql
  volumeClaimTemplates:
  - metadata:
      name: postgres-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi
---
apiVersion: v1
kind: Service
metadata:
  name: inventory-service-db
  namespace: ecommerce
spec:
  selector:
    app: inventory-postgres
  ports:
    - protocol: TCP
      port: 5432
      targetPort: 5432
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kafka
  namespace: ecommerce
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kafka
  template:
    metadata:
      labels:
        app: kafka
    spec:
      containers:
        - name: kafka
          image: apache/kafka:latest
          ports:
            - containerPort: 29092
            - containerPort: 29093
          env:
            - name: KAFKA_BROKER_ID
              value: "1"
            - name: KAFKA_LISTENER_SECURITY_PROTOCOL_MAP
              value: "INTERNAL:PLAINTEXT,CONTROLLER:PLAINTEXT"
            - name: KAFKA_ADVERTISED_LISTENERS
              value: "INTERNAL://kafka:29092"
            - name: KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR
              value: "1"
            - name: KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS
              value: "0"
            - name: KAFKA_TRANSACTION_STATE_LOG_MIN_ISR
              value: "1"
            - name: KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR
              value: "1"
            - name: KAFKA_PROCESS_ROLES
              value: "broker,controller"
            - name: KAFKA_NODE_ID
              value: "1"
            - name: KAFKA_CONTROLLER_QUORUM_VOTERS
              value: "1@kafka:29093"
            - name: KAFKA_LISTENERS
              value: "INTERNAL://:29092,CONTROLLER://:29093"
            - name: KAFKA_INTER_BROKER_LISTENER_NAME
              value: "INTERNAL"
            - name: KAFKA_CONTROLLER_LISTENER_NAMES
              value: "CONTROLLER"
            - name: KAFKA_HEAP_OPTS
              value: "-Xms512m -Xmx512m"
            - name: CLUSTER_ID
              value: "ecommerce"
#          resources:
#            limits:
#              memory: "512Mi"
#              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: kafka
  namespace: ecommerce
spec:
  selector:
    app: kafka
  ports:
    - name: internal
      protocol: TCP
      port: 29092
      targetPort: 29092
    - name: controller
      protocol: TCP
      port: 29093
      targetPort: 29093
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kafka-ui-ingress
  namespace: ecommerce
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: web
spec:
  ingressClassName: traefik
  rules:
    - host: kafka.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: kafka-ui
                port:
                  number: 8080
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kafka-ui
  namespace: ecommerce
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kafka-ui
  template:
    metadata:
      labels:
        app: kafka-ui
    spec:
      containers:
        - name: kafka-ui
          image: provectuslabs/kafka-ui:latest
          ports:
            - containerPort: 8080
          env:
            - name: KAFKA_CLUSTERS_0_NAME
              value: "ecommerce"
            - name: KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS
              value: "kafka:29092"
            - name: DYNAMIC_CONFIG_ENABLED
              value: "true"
            - name: SPRING_PROFILES_ACTIVE
              value: "prod"
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: kafka-ui
  namespace: ecommerce
spec:
  selector:
    app: kafka-ui
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
      name: http
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: debezium
  namespace: ecommerce
spec:
  replicas: 1
  selector:
    matchLabels:
      app: debezium
  template:
    metadata:
      labels:
        app: debezium
    spec:
      containers:
        - name: debezium
          image: quay.io/debezium/connect
          ports:
            - containerPort: 8083
          env:
            - name: BOOTSTRAP_SERVERS
              value: kafka:29092
            - name: GROUP_ID
              value: "1"
            - name: CONFIG_STORAGE_TOPIC
              value: debezium_config
            - name: OFFSET_STORAGE_TOPIC
              value: debezium_offsets
            - name: STATUS_STORAGE_TOPIC
              value: debezium_status
            - name: KEY_CONVERTER_SCHEMAS_ENABLE
              value: "false"
            - name: VALUE_CONVERTER_SCHEMAS_ENABLE
              value: "false"
            - name: CONNECT_KEY_CONVERTER
              value: org.apache.kafka.connect.json.JsonConverter
            - name: CONNECT_VALUE_CONVERTER
              value: org.apache.kafka.connect.json.JsonConverter
            - name: CONNECT_ACCESS_CONTROL_ALLOW_ORIGIN
              value: "*"
            - name: CONNECT_ACCESS_CONTROL_ALLOW_METHODS
              value: "GET"
            - name: CONNECT_ACCESS_CONTROL_ALLOW_HEADERS
              value: "origin,content-type,accept,authorization"
#          resources:
#            limits:
#              memory: "512Mi"
#              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: debezium
  namespace: ecommerce
spec:
  selector:
    app: debezium
  ports:
    - protocol: TCP
      port: 8083
      targetPort: 8083
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: debezium-ingress
  namespace: ecommerce
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: web
spec:
  ingressClassName: traefik
  rules:
    - host: debezium.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: debezium
                port:
                  number: 8083
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: debezium-ui
  namespace: ecommerce
spec:
  replicas: 1
  selector:
    matchLabels:
      app: debezium-ui
  template:
    metadata:
      labels:
        app: debezium-ui
    spec:
      containers:
        - name: debezium-ui
          image: docker.io/metelyoff/debezium-ui-arm64:latest
          ports:
            - containerPort: 80
          env:
            - name: KAFKA_CONNECT_CLUSTERS
              value: "http://debezium.local/,http://debezium:8083/"
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: debezium-ui
  namespace: ecommerce
spec:
  selector:
    app: debezium-ui
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 80
      name: http
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: debezium-ui-ingress
  namespace: ecommerce
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: web
spec:
  ingressClassName: traefik
  rules:
    - host: debezium-ui.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: debezium-ui
                port:
                  number: 8080
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: debezium-connectors
  namespace: ecommerce
data:
  register-connectors.sh: |
    #!/bin/sh
    echo "Registering connectors"
    for f in /connectors/*.json; do
      name=$(grep -o '"name"[[:space:]]*:[[:space:]]*"[^"]*"' "$f" | head -n1 | cut -d':' -f2 | tr -d ' "')
      echo "Registering connector: $name"
      response=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
        -H "Content-Type: application/json" \
        --data @"$f" http://debezium:8083/connectors)
    
      if [ "$response" -eq 201 ]; then
        echo "Registered $name"
      elif [ "$response" -eq 200 ]; then
        echo "Registered $name"
      elif [ "$response" -eq 409 ]; then
        echo "Connector $name already exists"
      else
        echo "Failed to register $name (HTTP $response)"
      fi
    done
  inventory-service-connector.json: |
    {
      "name": "inventory-service-connector",
      "config": {
        "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
        "tasks.max": "1",
        "database.hostname": "inventory-service-db",
        "database.port": "5432",
        "database.user": "${INVENTORY_POSTGRES_USER}",
        "database.password": "${INVENTORY_POSTGRES_PASSWORD}",
        "database.dbname": "inventory_service_db",
        "database.server.name": "inventory_service",
        "plugin.name": "pgoutput",
        "slot.name": "debezium_slot",
        "topic.prefix": "inventory-service",
        "key.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter.schemas.enable": "false",
        "decimal.handling.mode": "string",
        "include.transaction": true,
        "after.state.only": "true",
        "transforms": "unwrap",
        "transforms.unwrap.type": "io.debezium.transforms.ExtractNewRecordState",
        "transforms.unwrap.drop.tombstones": "true",
        "table.include.list": "public.outbox_events"
      }
    }
  order-service-connector.json: |
    {
      "name": "order-service-connector",
      "config": {
        "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
        "tasks.max": "1",
        "database.hostname": "order-service-db",
        "database.port": "5432",
        "database.user": "${ORDER_POSTGRES_USER}",
        "database.password": "${ORDER_POSTGRES_PASSWORD}",
        "database.dbname": "order_service_db",
        "database.server.name": "order_service",
        "plugin.name": "pgoutput",
        "slot.name": "debezium_slot",
        "topic.prefix": "order-service",
        "key.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter.schemas.enable": "false",
        "decimal.handling.mode": "string",
        "include.transaction": true,
        "after.state.only": "true",
        "transforms": "unwrap",
        "transforms.unwrap.type": "io.debezium.transforms.ExtractNewRecordState",
        "transforms.unwrap.drop.tombstones": "true",
        "table.include.list": "public.outbox_events"
      }
    }
  payment-service-connector.json: |
    {
      "name": "payment-service-connector",
      "config": {
        "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
        "tasks.max": "1",
        "database.hostname": "payment-service-db",
        "database.port": "5432",
        "database.user": "${PAYMENT_POSTGRES_USER}",
        "database.password": "${PAYMENT_POSTGRES_PASSWORD}",
        "database.dbname": "payment_service_db",
        "database.server.name": "payment_service",
        "plugin.name": "pgoutput",
        "slot.name": "debezium_slot",
        "topic.prefix": "payment-service",
        "key.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter": "org.apache.kafka.connect.json.JsonConverter",
        "value.converter.schemas.enable": "false",
        "decimal.handling.mode": "string",
        "include.transaction": true,
        "after.state.only": "true",
        "transforms": "unwrap",
        "transforms.unwrap.type": "io.debezium.transforms.ExtractNewRecordState",
        "transforms.unwrap.drop.tombstones": "true",
        "table.include.list": "public.outbox_events"
      }
    }
---
apiVersion: batch/v1
kind: Job
metadata:
  name: debezium-connector
  namespace: ecommerce
spec:
  template:
    spec:
      restartPolicy: Never
      initContainers:
        - name: wait-for-debezium
          image: curlimages/curl
          command:
            - sh
            - -c
            - |
              echo "Waiting for Debezium to become available..."
              until curl -s http://debezium:8083/connectors > /dev/null; do
                echo "Debezium not ready, retrying..."
                sleep 3
              done
              echo "Debezium is ready!"
      containers:
        - name: debezium-connector
          image: curlimages/curl
          command: ["sh", "/connectors/register-connectors.sh"]
          volumeMounts:
            - name: connector-configs
              mountPath: /connectors
      volumes:
        - name: connector-configs
          configMap:
            name: debezium-connectors
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: payment-service
  namespace: ecommerce
  labels:
    app: payment-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: payment-service
  template:
    metadata:
      labels:
        app: payment-service
    spec:
      containers:
        - name: payment-service
          image: ${IMAGE_NAME}:payment-service
          ports:
            - containerPort: 8080
          env:
            - name: DATABASE_URL
              value: jdbc:postgresql://payment-service-db:5432/payment_service_db
            - name: DATABASE_USERNAME
              value: "${PAYMENT_POSTGRES_USER}"
            - name: DATABASE_PASSWORD
              value: "${PAYMENT_POSTGRES_PASSWORD}"
            - name: KAFKA_URI
              value: kafka:29092
            - name: DEBEZIUM_DESTINATION
              value: payment-service.public.outbox_events
            - name: OUTBOX_TOPICS
              value: order-service.public.outbox_events,inventory-service.public.outbox_events
            - name: EXPIRE_DELAY_MILLIS
              value: "60000"
          readinessProbe:
            httpGet:
              path: /actuator/health
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
            failureThreshold: 10
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: payment-service
  namespace: ecommerce
spec:
  selector:
    app: payment-service
  ports:
    - protocol: TCP
      port: 8085
      targetPort: 8080
      name: http
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: inventory-service
  namespace: ecommerce
  labels:
    app: inventory-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: inventory-service
  template:
    metadata:
      labels:
        app: inventory-service
    spec:
      containers:
        - name: inventory-service
          image: ${IMAGE_NAME}:inventory-service
          ports:
            - containerPort: 8080
          env:
            - name: DATABASE_URL
              value: jdbc:postgresql://inventory-service-db:5432/inventory_service_db
            - name: DATABASE_USERNAME
              value: "${INVENTORY_POSTGRES_USER}"
            - name: DATABASE_PASSWORD
              value: "${INVENTORY_POSTGRES_PASSWORD}"
            - name: KAFKA_URI
              value: kafka:29092
            - name: DEBEZIUM_DESTINATION
              value: inventory-service.public.outbox_events
            - name: OUTBOX_TOPICS
              value: order-service.public.outbox_events,payment-service.public.outbox_events
          readinessProbe:
            httpGet:
              path: /actuator/health
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
            failureThreshold: 10
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: inventory-service
  namespace: ecommerce
spec:
  selector:
    app: inventory-service
  ports:
    - protocol: TCP
      port: 8084
      targetPort: 8080
      name: http
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service
  namespace: ecommerce
  labels:
    app: order-service
spec:
  replicas: 1
  selector:
    matchLabels:
      app: order-service
  template:
    metadata:
      labels:
        app: order-service
    spec:
      containers:
        - name: order-service
          image: ${IMAGE_NAME}:order-service
          ports:
            - containerPort: 8080
          env:
            - name: DATABASE_URL
              value: jdbc:postgresql://order-service-db:5432/order_service_db
            - name: DATABASE_USERNAME
              value: "${ORDER_POSTGRES_USER}"
            - name: DATABASE_PASSWORD
              value: "${ORDER_POSTGRES_PASSWORD}"
            - name: KAFKA_URI
              value: kafka:29092
            - name: DEBEZIUM_DESTINATION
              value: order-service.public.outbox_events
            - name: OUTBOX_TOPICS
              value: payment-service.public.outbox_events,inventory-service.public.outbox_events
          readinessProbe:
            httpGet:
              path: /actuator/health
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
            failureThreshold: 10
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: order-service
  namespace: ecommerce
spec:
  selector:
    app: order-service
  ports:
    - protocol: TCP
      port: 8086
      targetPort: 8080
      name: http
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
  namespace: ecommerce
  labels:
    app: web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
        - name: web
          image: ${IMAGE_NAME}:webapp
          ports:
            - containerPort: 80
          env:
            - name: REACT_APP_PRODUCTS_API_URL
              value: "https://${DOMAIN}/api"
            - name: REACT_APP_ORDERS_API_URL
              value: "https://${DOMAIN}/api"
            - name: REACT_APP_PAYMENTS_API_URL
              value: "https://${DOMAIN}/api"
            - name: BACKEND_PRODUCTS_API_URL
              value: http://inventory-service:8084
            - name: BACKEND_ORDERS_API_URL
              value: http://order-service:8086
            - name: BACKEND_PAYMENTS_API_URL
              value: http://payment-service:8085
          readinessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 30
            timeoutSeconds: 10
            failureThreshold: 3
          resources:
            limits:
              memory: "512Mi"
              cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: web
  namespace: ecommerce
spec:
  selector:
    app: web
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
      name: http
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web-ingress
  namespace: ecommerce
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
    - host: "${DOMAIN}"
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web
                port:
                  number: 80
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cloudflared-config
  namespace: ecommerce
data:
  config.yml: |
    tunnel: rpik3s-tunnel
    credentials-file: /etc/cloudflared/creds.json
    ingress:
      - hostname: "${DOMAIN}"
        service: http://web.ecommerce.svc.cluster.local:80
      - service: http_status:404
---
apiVersion: v1
kind: Secret
metadata:
  name: cloudflared-creds
  namespace: ecommerce
type: Opaque
data:
  creds.json: "${CLOUDFLARE_TUNNEL_TOKEN}"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cloudflared
  namespace: ecommerce
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cloudflared
  template:
    metadata:
      labels:
        app: cloudflared
    spec:
      initContainers:
        - name: wait-for-web
          image: curlimages/curl
          command: ['sh', '-c', 'until curl -s web:80 > /dev/null; do echo waiting for web; sleep 2; done;']
      containers:
        - name: cloudflared
          image: cloudflare/cloudflared:latest
          args:
            - tunnel
            - run
            - rpik3s-tunnel
          volumeMounts:
            - name: config
              mountPath: /etc/cloudflared/config.yml
              subPath: config.yml
            - name: creds
              mountPath: /etc/cloudflared/creds.json
              subPath: creds.json
      volumes:
        - name: config
          configMap:
            name: cloudflared-config
        - name: creds
          secret:
            secretName: cloudflared-creds
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: monitoring
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
    scrape_configs:
      - job_name: 'kubernetes'
        static_configs:
          - targets: ['order-service:8086', 'payment-service:8085', 'inventory-service:8084']
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
        - name: prometheus
          image: prom/prometheus
          args:
            - "--config.file=/etc/prometheus/prometheus.yml"
          ports:
            - containerPort: 9090
          volumeMounts:
            - name: config
              mountPath: /etc/prometheus
      volumes:
        - name: config
          configMap:
            name: prometheus-config
---
apiVersion: v1
kind: Service
metadata:
  name: prometheus
  namespace: monitoring
spec:
  selector:
    app: prometheus
  ports:
    - protocol: TCP
      port: 9090
      targetPort: 9090
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      containers:
        - name: grafana
          image: grafana/grafana
          ports:
            - containerPort: 3000
---
apiVersion: v1
kind: Service
metadata:
  name: grafana
  namespace: monitoring
spec:
  selector:
    app: grafana
  ports:
    - protocol: TCP
      port: 3000
      targetPort: 3000
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: grafana-ingress
  namespace: monitoring
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: web
spec:
  ingressClassName: traefik
  rules:
    - host: grafana.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: grafana
                port:
                  number: 3000
